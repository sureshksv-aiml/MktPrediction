---
description: 
globs: *.py
alwaysApply: false
---
# Python Function Return Type Annotations Required

## Context
Missing return type annotations in Python functions reduce code clarity, prevent static type checking, and make it harder for IDEs to provide accurate autocompletion and error detection. All functions should have explicit return type annotations to improve code maintainability and catch potential bugs during development.

## Rule
1. **All functions must have explicit return type annotations**.
2. **Use `-> None` for functions that don't return a value**.
3. **Use specific types** for functions that return values (`-> str`, `-> int`, `-> List[str]`, etc.).
4. **Use `Optional[T]` for functions that might return `None`**.
5. **Use `Union[T, U]` for functions that can return multiple types**.

## Examples

### ❌ Bad (Missing Return Type Annotations)
```python
def process_data(data):
    return data.upper()

def save_file(path, content):
    # No return value
    with open(path, 'w') as f:
        f.write(content)

async def fetch_data():
    return await api_call()

def get_user(user_id):
    if user_id:
        return User(user_id)
    return None
```

### ✅ Good (With Return Type Annotations)
```python
def process_data(data: str) -> str:
    return data.upper()

def save_file(path: str, content: str) -> None:
    # No return value
    with open(path, 'w') as f:
        f.write(content)

async def fetch_data() -> Dict[str, str]:
    return await api_call()

def get_user(user_id: Optional[str]) -> Optional[User]:
    if user_id:
        return User(user_id)
    return None
```

## Common Return Types

| Function Type | Return Type Annotation |
|---------------|----------------------|
| No return value | `-> None` |
| String | `-> str` |
| Integer | `-> int` |
| Boolean | `-> bool` |
| List | `-> List[str]` |
| Dictionary | `-> Dict[str, int]` |
| Optional return | `-> Optional[str]` |
| Multiple types | `-> Union[str, int]` |
| Async function | `-> Coroutine[Any, Any, str]` or `-> str` |
| Generator | `-> Iterator[str]` |

## Special Cases

### Async Functions
```python
# Good
async def fetch_user(user_id: str) -> User:
    return await database.get_user(user_id)

async def process_batch() -> None:
    await background_task()
```

### Generator Functions
```python
# Good
def generate_numbers(n: int) -> Iterator[int]:
    for i in range(n):
        yield i

def read_lines(file_path: str) -> Generator[str, None, None]:
    with open(file_path) as f:
        for line in f:
            yield line.strip()
```

### Class Methods
```python
# Good
class DataProcessor:
    def __init__(self, config: Config) -> None:
        self.config = config
    
    def process(self, data: str) -> ProcessingResult:
        return ProcessingResult(processed=data.upper())
    
    @classmethod
    def from_config(cls, config_path: str) -> 'DataProcessor':
        return cls(Config.load(config_path))
    
    @staticmethod
    def validate_input(data: str) -> bool:
        return len(data) > 0
```

## Mypy Error Prevention
This rule prevents these common mypy errors:
- `Function is missing a return type annotation`
- `no-untyped-def`
- `Returning Any from function declared to return X`

## Import Requirements
```python
from typing import (
    Any, Dict, List, Optional, Union, 
    Iterator, Generator, Coroutine
)
```

## Checklist for the Assistant
- [ ] Add return type annotations to all functions
- [ ] Use `-> None` for functions with no return value
- [ ] Use specific types like `-> str`, `-> int` for return values
- [ ] Use `Optional[T]` for functions that might return None
- [ ] Use `Union[T, U]` for functions returning multiple types
- [ ] Include proper imports for complex types
- [ ] Add return type annotations to async functions
- [ ] Add return type annotations to class methods and static methods

This ensures proper type checking and prevents mypy errors related to missing return type annotations.
